(ns maglev-hash.maglev)

(def h1 hash)
(def h2 (comp hash hash))

(defn permutations
  "Lazy seq of permutations for a node"
  [m id]
  (let [offset (-> id h1 (mod m))
        skip (-> id h2 (mod (dec m)) inc)]
    (for [j (range m)]
      (-> j (* skip) (+ offset) (mod m)))))

(def primes "Infinite, lazy sequence of prime numbers."
  ((fn step [m n]
     (or (some-> (get m n)
           (-> (->> (reduce #(update %1 (+ %2 n) conj %2) (dissoc m n)))
             (step (inc n))))
         (-> (assoc m (* n n) (list n))
           (step (inc n))
           (->> (cons n) (lazy-seq)))))
   {} 2))

(defn next-prime
  "Return next prime number >= n"
  [n]
  (if (nil? n) 2
      (first (filter #(>= % n) primes))))

(defn populate
  "Populate Maglev hashing lookup table
  (See Maglev paper page 6)"
  ([nodes] (populate nodes (-> nodes count (* 100) next-prime)))
  ([nodes m]
   (loop [entries {}
          node-seq (cycle (sort nodes))
          preferences (into {} (for [node nodes] [node (permutations m node)]))
          n 0]
     (let [[node & next-nodes] node-seq
           [entry & next-entries] (preferences node)
           next-prefs (assoc preferences node next-entries)]
       (if (= n m)
         (->> entries (into (sorted-map)) vals vec) ; return as a vector
         (if (entries entry) ; If slot already taken,
           (recur entries node-seq next-prefs n) ; try again with same node.
           (recur (assoc entries entry node) next-nodes next-prefs (inc n))))))))

(defn lookup
  "Use a lookup table generated by populate to determine node assigned to x"
  [table x]
  (-> x hash (mod (count table)) table))

(comment
  (def table (populate [:a :b :c :d]))
  (lookup table :foo) ; => :d
  (lookup table :bar) ; => :a

  (->> (populate ["a" "b" "c"])
    frequencies
    (into (sorted-map))) ;  => {"a" 103, "b" 102, "c" 102}
)
